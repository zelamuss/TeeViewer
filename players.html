<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Players - TeeViewer</title>
    <script src="api.js" type="module"></script>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="TeeAssembler/css/Tee.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <script src="TeeAssembler/js/color.js"></script>
    <script src="TeeAssembler/js/TeeAssembler.js"></script>
    <style>
        #onlineStatusSection {
        background: var(--glass-bg);
        backdrop-filter: blur(15px);
        border: 1px solid var(--glass-border);
        border-radius: 12px;
        padding: 20px;
        margin-top: 20px; /* Added margin for separation */
        text-align: center;
        color: var(--text-color);

            
        margin-bottom: 20px;
        font-size: 1em;
    }

    #onlineStatusSection h3 {
        color: var(--primary-color);
        font-size: 1.5em;
        margin-bottom: 15px;
    }

    #onlineStatusSection h4 {
        color: var(--primary-color);
        font-size: 1.2em;
        margin-top: 15px;
        margin-bottom: 10px;
    }

    #onlineStatusSection p {
        color: var(--text-color);
        margin-bottom: 5px;
        font-size: 1em;
    }

    #onlineStatusSection strong {
        color: var(--primary-color);
    }

    #onlineStatusSection button {
        background-color: var(--primary-color);
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1em;
        margin: 10px 5px;
        transition: background-color 0.3s ease, transform 0.2s ease;
    }

    #onlineStatusSection button:hover {
        background-color: var(--accent-color);
        transform: translateY(-1px);
    }

        /* Unified styling for all main content sections */
        .pie-charts-section,
        .completion-progress-section,
        .recent-top-10s-section,
        .rank-distribution-section,
        .all-top-10s-section,
        .recent-finishes,
        .unfinished-maps,
        .additional-details,
        .favourite-teammates-section,
        .most-played-maps-section,
        .playtime-graph-section,
        .points-graph-section {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            color: var(--text-color);
        }

        /* Unified styling for all section headers */
        .recent-top-10s-section h2,
        .rank-distribution-section h2,
        .all-top-10s-section h2,
        .recent-finishes h2,
        .unfinished-maps h2,
        .additional-details h2,
        .favourite-teammates-section h2,
        .most-played-maps-section h2,
        .playtime-graph-section h2,
        .points-graph-section h2,
        .pie-charts-section h2,
        .completion-progress-section h2 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .most-played-maps-section h3{
            text-align: center;
        }

        .card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            text-align: left;
            display: flex;
            flex-direction: column;
        }

        .card h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.3em;
            text-align: center;
        }

        .table-container {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            max-height: 400px;
            overflow-y: auto;
            margin-top: 15px;
            border: none;
            border-radius: 8px;
            background: transparent;
            flex-grow: 1;
        }

        .top-ranks-section .button,
        .all-top-10s-section .button {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 25px;
            transition: background-color 0.3s ease;
            align-self: center;
        }

        .top-ranks-section .button:hover,
        .all-top-10s-section .button:hover {
            background-color: var(--accent-color);
        }

        @media (max-width: 768px) {
            .table-container {
                max-height: 300px;
            }
        }
        .pie-charts-section h2, .completion-progress-section h2 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .pie-charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .pie-chart-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
        }

        .pie-chart-card h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .pie-chart-container {
            position: relative;
            height: 250px;
            width: 100%;
        }

        .completion-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .completion-table th {
            text-align: center;
            padding: 12px 15px;
            background-color: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid var(--glass-border);
            color: var(--primary-color);
        }

        .completion-table td {
            text-align: center;
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            color: var(--primary-color);
        }

        .completion-table tr:hover {
            background-color: rgba(255, 255, 255, 0.02);
        }

        .progress-bar-container {
            width: 100%;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            height: 20px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), #ff6b35);
            border-radius: 10px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .total-completion {
            margin-bottom: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .total-completion h3 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .total-progress-bar-container {
            width: 100%;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            overflow: hidden;
            height: 30px;
            margin-top: 10px;
        }

        .total-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            border-radius: 15px;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            font-weight: bold;
        }
        .player-search-container {
            max-width: 800px;
            margin: 20px auto;
            padding: 0 20px;
            text-align: center;
        }

        .search-area {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }

        .search-input {
            text-align: center;
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 12px 20px;
            color: var(--text-color);
            font-family: 'SF Pro Rounded', sans-serif;
            font-size: 16px;
            min-width: 300px;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 15px rgba(255, 69, 0, 0.3);
        }

        .loading-indicator {
            color: var(--primary-color);
            font-size: 1.1em;
            margin-top: 20px;
            display: none;
        }

        .error-message {
            color: #e74c3c;
            font-size: 1.1em;
            margin-top: 20px;
            display: none;
        }

        .player-container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
            color: var(--primary-color);
            display: none;
        }

        .player-profile {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 30px;
            flex-wrap: wrap;
            text-align: center;
            position: relative;
        }

        .player-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4em;
            color: white;
            text-transform: uppercase;
            flex-shrink: 0;
            overflow: hidden;
        }
        
        .player-avatar canvas {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }
        .player-info {
            justify-content: center;
            text-align: center;
            margin-left: 10%;
        }
        .player-info h1 {
            font-size: 2.5em;
            margin-bottom: 5px;
            color: var(--primary-color);
            
        }

        .player-info p {
            font-size: 1.1em;
            margin-bottom: 5px;
            color: var(--primary-color);
        }

        .player-info .country-display {
            display: flex;
            gap: 10px;
        }
        #countryFlag {
        position: absolute;
        top: 80px;
        right: 0px;
        flex: 1;
        text-align: right;
        opacity: 0.8;
        transition: opacity 0.2s ease;
        width: 200px;
        height: auto;
        
        }

        #countryFlag:hover {
            opacity: 1;
        }
        .player-info .country-flag {
            width: 24px;
            height: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }

        .player-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .stat-card .label {
            font-size: 0.9em;
            color: var(--primary-color);
        }

        .finishes-table, .unfinished-table, .teammates-table, .most-played-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .finishes-table th, .unfinished-table th, .teammates-table th, .most-played-table th {
            text-align: center;
            padding: 12px 15px;
            background-color: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid var(--glass-border);
            color: var(--primary-color);
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }

        .finishes-table td, .unfinished-table td, .teammates-table td, .most-played-table td {
            text-align: center;
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            color: var(--primary-color);
        }

        .finishes-table tr:hover, .unfinished-table tr:hover, .teammates-table tr:hover, .most-played-table tr:hover {
            background-color: rgba(255, 255, 255, 0.02);
        }

        .additional-details p {
            margin-bottom: 10px;
            font-size: 1.1em;
            color: var(--primary-color);
        }
        .additional-details p span {
            color: var(--primary-color);
        }

        .graph-container {
            position: relative;
            height: 400px;
            width: 100%;
            margin-bottom: 20px;
        }
        
        .playtime-graph-section canvas,
        .points-graph-section canvas {
            color: white;
        }

        .player-search-container h2 {
            font-size: 2em;
            color: var(--primary-color);
            margin-bottom: 20px;
        }

        .share-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 8px 15px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .share-button:hover {
            background-color: #218838;
            transform: translateY(-1px);
        }

        .player-comparison-section {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 30px;
            margin: 20px auto;
            max-width: 1200px;
            display: none;
        }

        .player-comparison-section h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.8em;
            text-align: center;
        }

        .comparison-search-area {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .comparison-results {
            display: flex;
            gap: 20px;
            justify-content: space-around;
            flex-wrap: wrap;
        }

        .comparison-player-card {
            flex: 1;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .comparison-player-card h3 {
            color: var(--primary-color);
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        .comparison-player-card p {
            color: var(--primary-color);
            margin-bottom: 8px;
        }
        .comparison-player-card p span {
            color: var(--primary-color);
        }

        @media (max-width: 768px) {
            .player-profile {
                flex-direction: column;
                text-align: center;
            }
            .share-button {
                position: static;
                margin-top: 20px;
            }
            .player-avatar {
                flex: 1;
                display: flex;
                justify-content: center;
                align-items: center;
                text-align: center;
                height: 100%;
                margin-right: 32%;
                position: relative;
            }
            .player-avatar img {
                position: absolute;
                top: 50%;
                left: 20%;
                transform: translate(-50%, -50%);
            }
            .player-info {

                text-align: center;
            }
            .player-info .country-display {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="topbar">
        <img onclick="navigateToPage('index.html')" class="logo" src="logo.png" alt="DDNet Logo">
        <div class="nav-buttons">
            <button onclick="navigateToPage('players.html')" class="categories" id="players">Players</button>
            <button onclick="navigateToPage('clans.html')" class="categories" id="clans">Clans</button>
            <button onclick="navigateToPage('maps.html')" class="categories" id="maps">Maps</button>
            <button onclick="navigateToPage('servers.html')" class="categories" id="servers">Servers</button>
            <button onclick="navigateToPage('status.html')" class="categories" id="status">Status</button>
        </div>
    </div>

    <div class="player-search-container">
        <h2 style="text-align: center; color: var(--primary-color); font-size: 36px; margin-bottom: 30px; text-shadow: 0 0 10px rgba(255, 69, 0, 0.3);">Player Search</h2>
        <div class="search-area">
            <input type="text" id="playerSearchInput" class="search-input" placeholder="Enter player name">
            <br>
            <button id="searchPlayerButton"  class="categories">Search Player</button>
        </div>
        <div id="loadingIndicator" class="loading-indicator">Loading player data...</div>
        <div id="errorMessage" class="error-message"></div>
    </div>

    <div id="playerStatsContainer" class="player-container">
        <div class="player-profile">
        
        <div class='teeassembler-tee' style="cursor: pointer;"></div>
        <br>
        <p style="position: absolute; margin-top: 140px; margin-left: 3%;"><strong>Click to Copy!</strong></p>

            <div class="player-avatar" id="playerAvatar">

            </div>
            <div class="player-info">
                <h1 style="text-align: center; color: var(--primary-color); font-size: 36px; margin-bottom: 30px; text-shadow: 0 0 10px rgba(255, 69, 0, 0.3);" id="playerName"></h1>
                <p>Points: <span id="playerPoints"></span></p>
                <p>Clan: <span id="playerClan"><a href="#" id="playerClanLink">N/A</a></span></p>
                <p>Country: <span id="playerCountry"></span></p> <p>Skin Name: <span id="playerSkinName"></span></p>
            </div>
            <img id="countryFlag" class="country-flag" alt="country flag">
            <button class="share-button" onclick="sharePlayerProfile()">Share Profile</button>
            
        </div>
        

        <div class="player-stats">
            <div class="stat-card">
                <div class="value" id="totalFinishes"></div>
                <div class="label">Total Finishes</div>
            </div>
            <div class="stat-card">
                <div class="value" id="totalSecondsPlayed"></div>
                <div class="label">Total Time Played</div>
            </div>
            <div class="stat-card">
                <div class="value" id="lastSeen"></div>
                <div class="label">Last Seen</div>
            </div>
            <div class="stat-card">
                <div class="value" id="playerStartPlaytime"></div>
                <div class="label">Started Playing</div>
            </div>
        </div>
        <div id="onlineStatusSection" style="margin-top: 20px;">
            <h3>Online Status: <span id="onlineStatus">Loading...</span></h3>
            <div id="serverDetails" style="display: none;">
                <h4>Current Server:</h4>
                <p><strong>Name:</strong> <span id="serverName"></span></p>
                <p><strong>Map:</strong> <span id="serverMap"></span></p>
                <p><strong>Game Type:</strong> <span id="gameType"></span></p>
                <p><strong>Version:</strong> <span id="serverVersion"></span></p>
                <button id="serversTabButton">Servers Tab</button>
                <button id="copyServerInfoButton">Copy server info</button>
            </div>
        </div>
        <div class="additional-details">
            <h2>Additional Details</h2>
            <p>Is Mapper: <span id="isMapper"></span></p>
            <p>Body Color: <span id="playerBodyColor"></span></p>
            <p>Feet Color: <span id="playerFeetColor"></span></p>
        </div>

        <div class="playtime-graph-section">
            <h2>Playtime Per Month</h2>
            <div class="graph-container">
                <canvas id="playtimeChart"></canvas>
            </div>
        </div>

        <div class="points-graph-section">
            <h2>Points History</h2>
            <div class="graph-container">
                <canvas id="pointsChart"></canvas>
            </div>
        </div>
        <div class="pie-charts-section">
            <h2>Playing Statistics</h2>
            <div class="pie-charts-container">
                <div class="pie-chart-card">
                    <h3>Most Played Categories</h3>
                    <div class="pie-chart-container">
                        <canvas id="categoriesChart"></canvas>
                    </div>
                </div>
                <div class="pie-chart-card">
                    <h3>Most Played Locations</h3>
                    <div class="pie-chart-container">
                        <canvas id="locationsChart"></canvas>
                    </div>
                </div>
                <div class="pie-chart-card">
                    <h3>Most Played Gametypes</h3>
                    <div class="pie-chart-container">
                        <canvas id="gametypesChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="completion-progress-section">
            <h2>Completion Progress</h2>
            <div class="total-completion">
                <h3>Total Completion</h3>
                <p id="totalCompletionText">0 / 0 maps completed (0%)</p>
                <div class="total-progress-bar-container">
                    <div id="totalProgressBar" class="total-progress-bar" style="width: 0%;">0%</div>
                </div>
            </div>
            <table class="completion-table">
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Progress</th>
                        <th>Maps Completed</th>
                        <th>Completion %</th>
                    </tr>
                </thead>
                <tbody id="completionProgressTableBody">
                </tbody>
            </table>
        </div>

        <div class="most-played-maps-section">
            <h2>Most Played Maps (by Total Time)</h2>
            <table class="most-played-table">
                <thead>
                    <tr>
                        <th>Map</th>
                        <th>Server</th>
                        <th>Total Time</th>
                    </tr>
                </thead>
                <tbody id="mostPlayedMapsTableBody">
                </tbody>
            </table>
        </div>
        
        <div class="recent-finishes">
            <h2>Recent Finishes</h2>
            <table class="finishes-table">
                <thead>
                    <tr>
                        <th>Map</th>
                        <th>Server</th>
                        <th>Time</th>
                        <th>Date</th>
                        <th>Rank</th>
                        <th>Team Rank</th>
                    </tr>
                </thead>
                <tbody id="recentFinishesTableBody">
                </tbody>
            </table>
        </div>

        <div class="recent-top-10s-section">
            <h2>Recent Top 10s</h2>
            <div class="table-container">
                <table id="recentTop10sTable" class="finishes-table">
                    <thead>
                        <tr>
                            <th>Rank Type</th>
                            <th>Map</th>
                            <th>Rank</th>
                            <th>Time (s)</th>
                            <th>Server</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="rank-distribution-section">
            <h2>Rank Distribution (Recent)</h2>
            <div class="table-container">
                <table id="rankDistributionTable" class="finishes-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Count</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
        </div>

        <div class="all-top-10s-section">
            <h2>All Top 10s</h2>
            <div class="table-container">
                <table id="allTop10sTable" class="finishes-table">
                    <thead>
                        <tr>
                            <th>Map</th>
                            <th>Rank</th>
                            <th>Time (s)</th>
                            <th>Server</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody>
                    </tbody>
                </table>
            </div>
            
        </div>

        <div class="favourite-teammates-section">
            <h2>Favourite Teammates</h2>
            <table class="teammates-table">
                <thead>
                    <tr>
                        <th>Teammate Name</th>
                        <th>Ranks Together</th>
                    </tr>
                </thead>
                <tbody id="favouriteTeammatesTableBody">
                </tbody>
            </table>
        </div>
    </div>


    <div class="player-comparison-section" id="playerComparisonSection">
        <h2>Compare Players</h2>
        <div class="comparison-search-area">
            <input type="text" id="player1SearchInput" class="search-input" placeholder="Player 1 Name">
            <input type="text" id="player2SearchInput" class="search-input" placeholder="Player 2 Name">
            <button id="comparePlayersButton" class="categories">Compare</button>
        </div>
        <div id="comparisonResults" class="comparison-results">
            </div>
        <div id="comparisonErrorMessage" class="error-message" style="display:none;"></div>
    </div>

    <script src="./country_codes.js"></script>
    <script>
        // Function to fetch and display online data
    async function fetchOnlineData(playerName) {
        const onlineStatusElement = document.getElementById('onlineStatus');
        const serverDetailsElement = document.getElementById('serverDetails');
        const serverNameElement = document.getElementById('serverName');
        const serverMapElement = document.getElementById('serverMap');
        const gameTypeElement = document.getElementById('gameType');
        const serverVersionElement = document.getElementById('serverVersion');
        const serversTabButton = document.getElementById('serversTabButton');
        const copyServerInfoButton = document.getElementById('copyServerInfoButton');

        // Reset display
        onlineStatusElement.textContent = 'Loading...';
        serverDetailsElement.style.display = 'none';
        serversTabButton.onclick = null;
        copyServerInfoButton.onclick = null;

        try {
            const response = await fetch(`https://api.status.tw/player/name/${playerName}`);
            const data = await response.json();

            if (data.players && data.players.length > 0) {
                const player = data.players[0];
                const server = player.server;

                onlineStatusElement.textContent = 'Online';
                onlineStatusElement.style.color = 'green';
                serverDetailsElement.style.display = 'block';

                serverNameElement.textContent = server.name;
                serverMapElement.textContent = server.map.name;
                gameTypeElement.textContent = server.gameType.name;
                serverVersionElement.textContent = server.version.version;

                const serverIp = server.ip;
                const serverPort = server.port;

                serversTabButton.onclick = () => {
                    window.location.href = `servers.html?ip=${serverIp}&port=${serverPort}`;
                };

                copyServerInfoButton.onclick = async () => {
                    const serverInfo = `${serverIp}:${serverPort}`;
                    try {
                        await navigator.clipboard.writeText(serverInfo);
                        showCustomModal('Copied to clipboard: ' + serverInfo);
                    } catch (err) {
                        console.error('Failed to copy: ', err);
                        showCustomModal('Failed to copy server info.');
                    }
                };
            } else {
                onlineStatusElement.textContent = 'Offline';
                onlineStatusElement.style.color = 'red';
                serverDetailsElement.style.display = 'none';
            }
        } catch (error) {
            console.error('Error fetching online data:', error);
            onlineStatusElement.textContent = 'Error fetching data.';
            onlineStatusElement.style.color = 'orange';
            serverDetailsElement.style.display = 'none';
        }
    }

    // Assuming you have a searchPlayer function, call fetchOnlineData after a successful player search
    // For example, if your searchPlayer function looks like this:
    /*
    function searchPlayer() {
        const playerName = playerSearchInput.value.trim();
        if (playerName) {
            // Your existing player search logic here
            // ...

            // Call the new function to get online data
            fetchOnlineData(playerName);
        }
    }
    */

    // Make sure to call `fetchOnlineData` whenever a player search is performed
    // For instance, if you have a `searchPlayer` function that gets triggered when the player name is entered or a search button is clicked:

    // Example of how to integrate with your existing searchPlayer logic
    // Find where your `playerSearchInput` is handled (e.g., in an event listener for 'keypress' or a 'searchPlayer' button click)
    // And add `fetchOnlineData(playerName);` there.

    document.addEventListener('DOMContentLoaded', () => {
        const playerSearchInput = document.getElementById('playerSearchInput'); // Assuming this is your main player search input
        const searchPlayerButton = document.getElementById('searchPlayerButton'); // Assuming you have a search button

        // You likely already have a searchPlayer function. Modify it to include the call to fetchOnlineData.
        // If your searchPlayer function is defined elsewhere, ensure you pass the player name to fetchOnlineData.
        if (searchPlayerButton) {
            searchPlayerButton.addEventListener('click', () => {
                const playerName = playerSearchInput.value.trim();
                if (playerName) {
                    // Call your existing searchPlayer logic here if any
                    // ...
                    fetchOnlineData(playerName);
                }
            });
        }

        if (playerSearchInput) {
            playerSearchInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    const playerName = playerSearchInput.value.trim();
                    if (playerName) {
                        // Call your existing searchPlayer logic here if any
                        // ...
                        fetchOnlineData(playerName);
                    }
                }
            });
        }

        // If you have a way to get the player name from the URL on load, also call fetchOnlineData
        const urlParams = new URLSearchParams(window.location.search);
        const playerNameFromUrl = urlParams.get('player');
        if (playerNameFromUrl) {
            playerSearchInput.value = playerNameFromUrl;
            fetchOnlineData(playerNameFromUrl); // Call when page loads with a player in URL
        }
    });

    // Assuming you have a modal function, if not, you can define a simple one
    // Function to fetch and display online data
    async function fetchOnlineData(playerName) {
        const onlineStatusElement = document.getElementById('onlineStatus');
        const serverDetailsElement = document.getElementById('serverDetails');
        const serverNameElement = document.getElementById('serverName');
        const serverMapElement = document.getElementById('serverMap');
        const gameTypeElement = document.getElementById('gameType');
        const serverVersionElement = document.getElementById('serverVersion');
        const serversTabButton = document.getElementById('serversTabButton');
        const copyServerInfoButton = document.getElementById('copyServerInfoButton');

        // Reset display
        onlineStatusElement.textContent = 'Loading...';
        serverDetailsElement.style.display = 'none';
        serversTabButton.onclick = null;
        copyServerInfoButton.onclick = null;

        try {
            const response = await fetch(`https://api.status.tw/player/name/${playerName}`);
            const data = await response.json();

            if (data.players && data.players.length > 0) {
                const player = data.players[0];
                const server = player.server;

                onlineStatusElement.textContent = 'Online';
                onlineStatusElement.style.color = 'green';
                serverDetailsElement.style.display = 'block';

                serverNameElement.textContent = server.name;
                serverMapElement.textContent = server.map.name;
                gameTypeElement.textContent = server.gameType.name;
                serverVersionElement.textContent = server.version.version;

                const serverIp = server.ip;
                const serverPort = server.port;

                serversTabButton.onclick = () => {
                    window.location.href = `servers.html?ip=${serverIp}&port=${serverPort}`;
                };

                copyServerInfoButton.onclick = async () => {
                    const serverInfo = `${serverIp}:${serverPort}`;
                    try {
                        await navigator.clipboard.writeText(serverInfo);
                        showCustomModal('Copied to clipboard: ' + serverInfo);
                    } catch (err) {
                        console.error('Failed to copy: ', err);
                        showCustomModal('Failed to copy server info.');
                    }
                };
            } else {
                onlineStatusElement.textContent = 'Offline';
                onlineStatusElement.style.color = 'red';
                serverDetailsElement.style.display = 'none';
            }
        } catch (error) {
            console.error('Error fetching online data:', error);
            onlineStatusElement.textContent = 'Error fetching data.';
            onlineStatusElement.style.color = 'orange';
            serverDetailsElement.style.display = 'none';
        }
    }

    // Assuming you have a searchPlayer function, call fetchOnlineData after a successful player search
    // For example, if your searchPlayer function looks like this:
    /*
    function searchPlayer() {
        const playerName = playerSearchInput.value.trim();
        if (playerName) {
            // Your existing player search logic here
            // ...

            // Call the new function to get online data
            fetchOnlineData(playerName);
        }
    }
    */

    // Make sure to call `fetchOnlineData` whenever a player search is performed
    // For instance, if you have a `searchPlayer` function that gets triggered when the player name is entered or a search button is clicked:

    // Example of how to integrate with your existing searchPlayer logic
    // Find where your `playerSearchInput` is handled (e.g., in an event listener for 'keypress' or a 'searchPlayer' button click)
    // And add `fetchOnlineData(playerName);` there.

    document.addEventListener('DOMContentLoaded', () => {
        const playerSearchInput = document.getElementById('playerSearchInput'); // Assuming this is your main player search input
        const searchPlayerButton = document.getElementById('searchPlayerButton'); // Assuming you have a search button

        // You likely already have a searchPlayer function. Modify it to include the call to fetchOnlineData.
        // If your searchPlayer function is defined elsewhere, ensure you pass the player name to fetchOnlineData.
        if (searchPlayerButton) {
            searchPlayerButton.addEventListener('click', () => {
                const playerName = playerSearchInput.value.trim();
                if (playerName) {
                    // Call your existing searchPlayer logic here if any
                    // ...
                    fetchOnlineData(playerName);
                }
            });
        }

        if (playerSearchInput) {
            playerSearchInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    const playerName = playerSearchInput.value.trim();
                    if (playerName) {
                        // Call your existing searchPlayer logic here if any
                        // ...
                        fetchOnlineData(playerName);
                    }
                }
            });
        }

        // If you have a way to get the player name from the URL on load, also call fetchOnlineData
        const urlParams = new URLSearchParams(window.location.search);
        const playerNameFromUrl = urlParams.get('player');
        if (playerNameFromUrl) {
            playerSearchInput.value = playerNameFromUrl;
            fetchOnlineData(playerNameFromUrl); // Call when page loads with a player in URL
        }
    });

    // Assuming you have a modal function, if not, you can define a simple one
    function showCustomModal(message) {
        const modal = document.createElement('div');
        modal.style.position = 'fixed';
        modal.style.top = '50%';
        modal.style.left = '50%';
        modal.style.transform = 'translate(-50%, -50%)';
        modal.style.backgroundColor = 'rgba(0,0,0,0.8)';
        modal.style.color = 'white';
        modal.style.padding = '15px';
        modal.style.borderRadius = '8px';
        modal.style.zIndex = '1000';
        modal.textContent = message;
        document.body.appendChild(modal);

        setTimeout(() => {
            document.body.removeChild(modal);
        }, 2000); // Remove after 2 seconds
    }
        let categoriesChartInstance = null;
        let locationsChartInstance = null;
        let gametypesChartInstance = null;
        async function loadTopRanksForPlayer(playerName) {
            if (!playerName) {
                console.warn('Player name is empty. Cannot fetch data.');
                document.getElementById('recentTop10sTable').getElementsByTagName('tbody')[0].innerHTML = '<tr><td colspan="6">Please enter a player name to view data.</td></tr>';
                document.getElementById('rankDistributionTable').getElementsByTagName('tbody')[0].innerHTML = '<tr><td colspan="2">Please enter a player name to view data.</td></tr>';
                document.getElementById('allTop10sTable').getElementsByTagName('tbody')[0].innerHTML = '';
                
                return;
            }

            const apiUrl = `https://ddstats.tw/player/json?player=${encodeURIComponent(playerName)}`;
            let playerData = null;

            try {
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    if (response.status === 404) {
                        showCustomModal(`Player "${playerName}" not found. Please check the spelling.`);
                    } else {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    document.getElementById('recentTop10sTable').getElementsByTagName('tbody')[0].innerHTML = '<tr><td colspan="6">Player data not found or error fetching.</td></tr>';
                    document.getElementById('rankDistributionTable').getElementsByTagName('tbody')[0].innerHTML = '<tr><td colspan="2">Player data not found or error fetching.</td></tr>';
                    document.getElementById('allTop10sTable').getElementsByTagName('tbody')[0].innerHTML = '';
                    
                    return;
                }
                playerData = await response.json();
            } catch (error) {
                console.error('Error fetching player data:', error);
                document.getElementById('recentTop10sTable').getElementsByTagName('tbody')[0].innerHTML = '<tr><td colspan="6">Error loading player data.</td></tr>';
                document.getElementById('rankDistributionTable').getElementsByTagName('tbody')[0].innerHTML = '<tr><td colspan="2">Error loading player data.</td></tr>';
                document.getElementById('allTop10sTable').getElementsByTagName('tbody')[0].innerHTML = '';
                
                return;
            }

            if (!playerData || !playerData.recent_top_10s) {
                document.getElementById('recentTop10sTable').getElementsByTagName('tbody')[0].innerHTML = '<tr><td colspan="6">No recent top 10s available for this player.</td></tr>';
                document.getElementById('rankDistributionTable').getElementsByTagName('tbody')[0].innerHTML = '<tr><td colspan="2">No rank distribution data available.</td></tr>';
                document.getElementById('allTop10sTable').getElementsByTagName('tbody')[0].innerHTML = '';
                
                return;
            }

            // --- Update Recent Top 10s Table ---
            const recentTop10sTbody = document.getElementById('recentTop10sTable').getElementsByTagName('tbody')[0];
            recentTop10sTbody.innerHTML = ''; // Clear existing rows

            // Use recent_top_10s for both Recent Top 10s and All Top 10s as per aoe.json
            const recentTop10s = playerData.recent_top_10s; 
            const allTop10s = playerData.all_top_10s || recentTop10s; // Fallback to recent_top_10s if all_top_10s is not available
            if (recentTop10s && recentTop10s.length > 0) {
                // Display up to 10 recent top 10s in this section initially
                recentTop10s.slice(0, 10).forEach(item => {
                    const row = recentTop10sTbody.insertRow();
                    row.insertCell().textContent = item.rank_type;
                    row.insertCell().textContent = item.map;
                    row.insertCell().textContent = item.rank;
                    row.insertCell().textContent = formatTime(item.time);
                    row.insertCell().textContent = item.server;
                    row.insertCell().textContent = item.timestamp ? new Date(item.timestamp).toLocaleDateString() : 'N/A';
                });
            } else {
                recentTop10sTbody.innerHTML = '<tr><td colspan="6">No recent top 10s available for this player.</td></tr>';
            }

            // --- Update Rank Distribution (Recent) as a Table ---
            const rankDistributionTableBody = document.getElementById('rankDistributionTable').getElementsByTagName('tbody')[0];
            rankDistributionTableBody.innerHTML = ''; // Clear existing content

            if (allTop10s && allTop10s.length > 0) {
                const rankCounts = {};
                allTop10s.forEach(item => {
                    const rank = item.rank;
                    rankCounts[rank] = (rankCounts[rank] || 0) + 1;
                });

                // Display counts for ranks 1-10 in table rows
                for (let i = 1; i <= 10; i++) {
                    const count = rankCounts[i] || 0;
                    const row = rankDistributionTableBody.insertRow();
                    row.insertCell().textContent = getOrdinalSuffix(i) ;
                    row.insertCell().textContent = count;
                }
            } else {
                rankDistributionTableBody.innerHTML = '<tr><td colspan="2">No rank distribution data available.</td></tr>';
            }

            // --- Update All Top 10s Table ---
            const allTop10sTbody = document.getElementById('allTop10sTable').getElementsByTagName('tbody')[0];
            
            const allTop10sData = playerData.all_top_10s; // Also use recent_top_10s for All Top 10s
            let displayedTop10s = allTop10sData.length; // Start with 10 displayed for 'All Top 10s' initially

            function displayAllTop10s() {
                allTop10sTbody.innerHTML = ''; // Clear existing rows
                if (allTop10sData && allTop10sData.length > 0) {
                    for (let i = 0; i < Math.min(displayedTop10s, allTop10sData.length); i++) {
                        const item = allTop10sData[i];
                        const row = allTop10sTbody.insertRow();
                        row.insertCell().textContent = item.map.map;
                        row.insertCell().textContent = item.rank;
                        row.insertCell().textContent = formatTime(item.time);
                        row.insertCell().textContent = item.map.server;
                        row.insertCell().textContent = item.map.timestamp ? new Date(item.map.timestamp).toLocaleDateString() : 'N/A';
                    }


                } else {
                    allTop10sTbody.innerHTML = '<tr><td colspan="6">No top 10s available.</td></tr>';
                    
                }
            }

            // Re-attach event listener to avoid duplicates if function is called multiple times
            


            displayAllTop10s(); // Initial display for All Top 10s
        }

        function getOrdinalSuffix(n) {
            const s = ["th", "st", "nd", "rd"];
            const v = n % 100;
            return n + (s[(v - 20) % 10] || s[v] || s[0]);
        }

        document.addEventListener('DOMContentLoaded', () => {
            const playerSearchInput = document.getElementById('playerSearchInput');
            const searchButton = document.getElementById('searchPlayerButton');

            if (searchButton) {
                searchButton.addEventListener('click', () => {
                    const playerName = playerSearchInput.value.trim();
                    searchPlayer(); // Call searchPlayer to load all data
                });
            }

            if (playerSearchInput) {
                playerSearchInput.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        searchPlayer(); // Call searchPlayer to load all data
                    }
                });
            }

            const urlParams = new URLSearchParams(window.location.search);
            const playerNameFromUrl = urlParams.get('player');
            if (playerNameFromUrl) {
                playerSearchInput.value = playerNameFromUrl;
                searchPlayer(); 
            } else {
                playerSearchInput.value = '';
                searchPlayer(); 
            }
        });
        function renderPieCharts(playerData) {
            if (categoriesChartInstance) {
                categoriesChartInstance.destroy();
                categoriesChartInstance = null;
            }
            if (locationsChartInstance) {
                locationsChartInstance.destroy();
                locationsChartInstance = null;
            }
            if (gametypesChartInstance) {
                gametypesChartInstance.destroy();
                gametypesChartInstance = null;
            }

            const generateColors = (count) => {
                const colors = [];
                const baseColors = [
                    '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                    '#FF9F40', '#C7CBCF', '#FF6384', '#36A2EB', '#FFCE56'
                ];
                for (let i = 0; i < count; i++) {
                    colors.push(baseColors[i % baseColors.length]);
                }
                return colors;
            };

            const categoriesCtx = document.getElementById('categoriesChart').getContext('2d');
            if (playerData.most_played_categories && playerData.most_played_categories.length > 0) {
                const categoriesData = playerData.most_played_categories.slice(0, 8);
                categoriesChartInstance = new Chart(categoriesCtx, {
                    type: 'pie',
                    data: {
                        labels: categoriesData.map(item => item.key),
                        datasets: [{
                            data: categoriesData.map(item => Math.round(item.seconds_played / 3600)),
                            backgroundColor: generateColors(categoriesData.length),
                            borderWidth: 2,
                            borderColor: 'rgba(255, 255, 255, 0.1)'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    color: 'white',
                                    padding: 15,
                                    fontSize: 12
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const hours = context.parsed;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = ((hours / total) * 100).toFixed(1);
                                        return `${context.label}: ${hours}h (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            } else {
                categoriesCtx.clearRect(0, 0, categoriesCtx.canvas.width, categoriesCtx.canvas.height);
                categoriesCtx.font = "16px 'SF Pro Rounded'";
                categoriesCtx.fillStyle = 'white';
                categoriesCtx.textAlign = 'center';
                categoriesCtx.fillText('No categories data available.', categoriesCtx.canvas.width / 2, categoriesCtx.canvas.height / 2);
            }

            const locationsCtx = document.getElementById('locationsChart').getContext('2d');
            if (playerData.most_played_locations && playerData.most_played_locations.length > 0) {
                const locationsData = playerData.most_played_locations.slice(0, 8);
                locationsChartInstance = new Chart(locationsCtx, {
                    type: 'pie',
                    data: {
                        labels: locationsData.map(item => item.key),
                        datasets: [{
                            data: locationsData.map(item => Math.round(item.seconds_played / 3600)),
                            backgroundColor: generateColors(locationsData.length),
                            borderWidth: 2,
                            borderColor: 'rgba(255, 255, 255, 0.1)'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    color: 'white',
                                    padding: 15,
                                    fontSize: 12
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const hours = context.parsed;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = ((hours / total) * 100).toFixed(1);
                                        return `${context.label}: ${hours}h (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            } else {
                locationsCtx.clearRect(0, 0, locationsCtx.canvas.width, locationsCtx.canvas.height);
                locationsCtx.font = "16px 'SF Pro Rounded'";
                locationsCtx.fillStyle = 'white';
                locationsCtx.textAlign = 'center';
                locationsCtx.fillText('No locations data available.', locationsCtx.canvas.width / 2, locationsCtx.canvas.height / 2);
            }

            const gametypesCtx = document.getElementById('gametypesChart').getContext('2d');
            if (playerData.most_played_gametypes && playerData.most_played_gametypes.length > 0) {
                const gametypesData = playerData.most_played_gametypes.slice(0, 8);
                gametypesChartInstance = new Chart(gametypesCtx, {
                    type: 'pie',
                    data: {
                        labels: gametypesData.map(item => item.key),
                        datasets: [{
                            data: gametypesData.map(item => Math.round(item.seconds_played / 3600)),
                            backgroundColor: generateColors(gametypesData.length),
                            borderWidth: 2,
                            borderColor: 'rgba(255, 255, 255, 0.1)'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                                labels: {
                                    color: 'white',
                                    padding: 15,
                                    fontSize: 12
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const hours = context.parsed;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = ((hours / total) * 100).toFixed(1);
                                        return `${context.label}: ${hours}h (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            } else {
                gametypesCtx.clearRect(0, 0, gametypesCtx.canvas.width, gametypesCtx.canvas.height);
                gametypesCtx.font = "16px 'SF Pro Rounded'";
                gametypesCtx.fillStyle = 'white';
                gametypesCtx.textAlign = 'center';
                gametypesCtx.fillText('No gametypes data available.', gametypesCtx.canvas.width / 2, gametypesCtx.canvas.height / 2);
            }
        }

        function renderCompletionProgress(playerData) {
            const completionProgressTableBody = document.getElementById('completionProgressTableBody');
            completionProgressTableBody.innerHTML = '';

            if (playerData.completion_progress && playerData.completion_progress.length > 0) {
                let totalMapsFinished = 0;
                let totalMapsTotal = 0;

                playerData.completion_progress.forEach(category => {
                    totalMapsFinished += category.maps_finished;
                    totalMapsTotal += category.maps_total;

                    const percentage = category.maps_total > 0 ? ((category.maps_finished / category.maps_total) * 100).toFixed(1) : 0;
                    
                    const row = completionProgressTableBody.insertRow();
                    row.insertCell().textContent = category.category;
                    
                    const progressCell = row.insertCell();
                    progressCell.innerHTML = `
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: ${percentage}%;">${percentage}%</div>
                        </div>
                    `;
                    
                    row.insertCell().textContent = `${category.maps_finished} / ${category.maps_total}`;
                    row.insertCell().textContent = `${percentage}%`;
                });

                const totalPercentage = totalMapsTotal > 0 ? ((totalMapsFinished / totalMapsTotal) * 100).toFixed(1) : 0;
                document.getElementById('totalCompletionText').textContent = `${totalMapsFinished} / ${totalMapsTotal} maps completed (${totalPercentage}%)`;
                document.getElementById('totalProgressBar').style.width = `${totalPercentage}%`;
                document.getElementById('totalProgressBar').textContent = `${totalPercentage}%`;
            } else {
                const row = completionProgressTableBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 4;
                cell.textContent = "No completion progress data found.";
                cell.style.textAlign = 'center';
                cell.style.padding = '20px';
                
                document.getElementById('totalCompletionText').textContent = 'No completion data available';
                document.getElementById('totalProgressBar').style.width = '0%';
                document.getElementById('totalProgressBar').textContent = '0%';
            }
        }

        function navigateToPage(url) {
            document.body.style.transform = 'translateX(-100%)';
            document.body.style.transition = 'transform 0.5s ease-in-out';
            
            setTimeout(() => {
                window.location.href = url;
            }, 250);
        }

        const playerSearchInput = document.getElementById('playerSearchInput');
        const searchPlayerButton = document.getElementById('searchPlayerButton');
        const playerStatsContainer = document.getElementById('playerStatsContainer');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const errorMessage = document.getElementById('errorMessage');

        let playtimeChartInstance = null;
        let pointsChartInstance = null;
        let currentPlayerName = null;
        let currentTeeInstance = null;
        let currentTeeAssemblerString = null; // Initialize this variable

        async function searchPlayer() {
            const playerName = playerSearchInput.value.trim();
            if (!playerName) {
                displayError("Please enter a player name.");
                return;
            }

            currentPlayerName = playerName;

            playerStatsContainer.style.display = 'none';
            errorMessage.style.display = 'none';
            loadingIndicator.style.display = 'block';
            document.getElementById('playerComparisonSection').style.display = 'none';

            // Destroy existing chart instances before creating new ones
            if (categoriesChartInstance) {
                categoriesChartInstance.destroy();
                categoriesChartInstance = null;
            }
            if (locationsChartInstance) {
                locationsChartInstance.destroy();
                locationsChartInstance = null;
            }
            if (gametypesChartInstance) {
                gametypesChartInstance.destroy();
                gametypesChartInstance = null;
            }
            if (playtimeChartInstance) {
                playtimeChartInstance.destroy();
                playtimeChartInstance = null;
            }
            if (pointsChartInstance) {
                pointsChartInstance.destroy();
                pointsChartInstance = null;
            }

            if (currentTeeInstance) {
                currentTeeInstance.destroy();
                currentTeeInstance = null;
            }
            document.getElementById('playerAvatar').innerHTML = '';

            try {
                const response = await fetch(`https://ddstats.tw/player/json?player=${encodeURIComponent(playerName)}`);
                if (!response.ok) {
                    if (response.status === 404) {
                        throw new Error(`Player '${playerName}' not found.`);
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const playerData = await response.json();

                if (Object.keys(playerData).length === 0 || !playerData.profile) {
                    throw new Error(`No detailed data available for player '${playerName}'.`);
                }

                displayPlayerData(playerData);
                loadTopRanksForPlayer(playerName); // Call this to load recent top 10s and rank distribution
            } catch (error) {
                console.error("Error fetching player data:", error);
                displayError(error.message || "Failed to fetch player data. Please try again.");
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        function rgbToHex(r, g, b) {
            return ((r << 16) | (g << 8) | b);
        }

        function displayPlayerData(playerData) {
            const profile = playerData.recent_player_info && playerData.recent_player_info.length > 0 ? playerData.recent_player_info[0] : playerData.profile;
            
            const data = playerData;
            console.log(data)
            console.log(profile)
            const skinbodyColor = profile.skin_color_body;

            const skinfeetColor = profile.skin_color_feet;

            const skinName = profile.skin_name || 'default';

            const effectiveBodyColor = skinbodyColor !== null ? skinbodyColor.toString() : '';

            const effectiveFeetColor = skinfeetColor !== null ? skinfeetColor.toString() : '';
            renderPieCharts(playerData);
            renderCompletionProgress(playerData);
            let myTee;
            console.log(effectiveBodyColor);

            if (typeof myTee !== 'undefined' && myTee !== null) {

                myTee.api.functions.unbindContainer();

                myTee = null;

                document.querySelector('.teeassembler-tee').innerHTML = '';

            }
            const teecontainer = document.querySelector('.teeassembler-tee')
            teecontainer.innerHTML = '';
            let test;
            if (skinbodyColor === null || skinfeetColor === null) {
                test = `player_skin ${skinName}; player_use_custom_color 0`;
            } else {
                test = `player_skin ${skinName}; player_color_body ${effectiveBodyColor}; player_color_feet ${effectiveFeetColor}; player_use_custom_color 1`;
            }
            currentTeeAssemblerString = test;
            console.log(test);
            const myTeeOptions = {

                container: teecontainer,

                imageLink: `https://ddstats.tw/skins/${skinName}.png`,

                bodyColor: effectiveBodyColor,

                feetColor: effectiveFeetColor,

                colorFormat: 'code'

            };
            
            
            if (typeof TeeAssembler !== 'undefined' && TeeAssembler.Tee) {

                if (myTee) {

                    myTee.api.functions.unbindContainer();

                }

                myTee = new TeeAssembler.Tee(myTeeOptions);

                myTee.api.functions.lookAtCursor();

            } else {

                console.warn("TeeAssembler library not loaded or not found.");

                document.querySelector('.teeassembler-tee').innerHTML = 'Tee preview not available.';

            }
            
            
            document.getElementById('playerName').textContent = profile.name || 'N/A';
            document.getElementById('playerPoints').textContent = playerData.profile.points || 0;

            const playerClan = document.getElementById('playerClanLink');
            if (profile.clan && profile.clan !== "") {
                playerClan.textContent = profile.clan;
                playerClan.href = `clans.html?clanName=${encodeURIComponent(profile.clan)}`;
            } else {
                playerClan.textContent = "N/A";
                playerClan.href = "#";
            }

            const countryCode = profile.country !== undefined && profile.country !== null ? profile.country.toString() : "-1";
            const countryName = COUNTRY_CODES[countryCode] || `Unknown (Code: ${countryCode})`;
            const countryFlag = document.getElementById('countryFlag');
                const regionNames = new Intl.DisplayNames(

                ['en'], {type: 'region'}

                );
            
            document.getElementById('playerCountry').textContent = countryName === "default" ? "Default" : regionNames.of(countryName);

            if (countryName !== "default") {
                countryFlag.src = `countryflags/${countryName}.png`;
                countryFlag.style.display = 'inline-block';
            } else {
                countryFlag.src = `countryflags/default.png`;
                countryFlag.style.display = 'inline-block';
            }

            document.getElementById('playerSkinName').textContent = profile.skin_name || 'N/A';
            document.getElementById('playerBodyColor').textContent = profile.skin_color_body
            document.getElementById('playerFeetColor').textContent = profile.skin_color_feet

            document.getElementById('isMapper').textContent = playerData.is_mapper ? 'Yes' : 'No';

            const totalFinishes = playerData.finishes ? playerData.finishes.length : 0;
            document.getElementById('totalFinishes').textContent = totalFinishes;

            let totalSecondsPlayed = 0;
            let earliestFinishDate = null;
            const mapPlaytime = {};

            if (playerData.finishes) {
                playerData.finishes.forEach(finish => {
                    totalSecondsPlayed += finish.seconds_played || 0;

                    if (finish.timestamp) {
                        const finishDate = new Date(finish.timestamp);
                        if (!earliestFinishDate || finishDate < earliestFinishDate) {
                            earliestFinishDate = finishDate;
                        }
                    }

                    const mapKey = `${finish.map.map} - ${finish.server}`;
                    mapPlaytime[mapKey] = (mapPlaytime[mapKey] || { totalTime: 0, mapName: finish.map.map, serverName: finish.server });
                    mapPlaytime[mapKey].totalTime += (finish.seconds_played || 0);
                });
            }
            document.getElementById('totalSecondsPlayed').textContent = formatTime(playerData.general_activity.total_seconds_played);
            document.getElementById('lastSeen').textContent = profile.last_seen ? new Date(profile.last_seen).toLocaleDateString() : 'N/A';
            document.getElementById('playerStartPlaytime').textContent = earliestFinishDate ? earliestFinishDate.toLocaleDateString() : 'N/A';

            const mostPlayedMapsTableBody = document.getElementById('mostPlayedMapsTableBody');
            mostPlayedMapsTableBody.innerHTML = '';
            const sortedMaps = Object.values(mapPlaytime).sort((a, b) => b.totalTime - a.totalTime).slice(0, 10);
            if (sortedMaps.length > 0) {
                sortedMaps.forEach(map => {
                    const row = mostPlayedMapsTableBody.insertRow();
                    const mapCell = row.insertCell();
                    row.insertCell().textContent = map.serverName;
                    row.insertCell().textContent = formatTime(map.totalTime);

                    const mapLink = document.createElement('a');
                    mapLink.href = `maps.html?map=${encodeURIComponent(map.mapName)}`;
                    mapLink.textContent = map.mapName;
                    mapLink.style.color = 'var(--primary-color)';
                    mapLink.style.textDecoration = 'underline';

                    mapCell.appendChild(mapLink);
                });
            } else {
                const row = mostPlayedMapsTableBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 3;
                cell.textContent = "No played maps data found.";
                cell.style.textAlign = 'center';
                cell.style.padding = '20px';
            }


            const recentFinishesTableBody = document.getElementById('recentFinishesTableBody');
            recentFinishesTableBody.innerHTML = '';
            if (playerData.recent_finishes && playerData.recent_finishes.length > 0) {
                playerData.recent_finishes.forEach(finish => {
                    const row = recentFinishesTableBody.insertRow();
                    const mapCell = row.insertCell();
                    row.insertCell().textContent = finish.server;
                    row.insertCell().textContent = finish.time ? formatTime(finish.time.toFixed(2)): 'N/A';
                    row.insertCell().textContent = finish.timestamp ? new Date(finish.timestamp).toLocaleDateString() : 'N/A';
                    row.insertCell().textContent = finish.rank || 'N/A';
                    row.insertCell().textContent = finish.team_rank || 'N/A';

                    const mapLink = document.createElement('a');
                    mapLink.href = `maps.html?map=${encodeURIComponent(finish.map.map)}`;
                    mapLink.textContent = finish.map.map;
                    mapLink.style.color = 'var(--primary-color)';
                    mapLink.style.textDecoration = 'underline';

                    mapCell.appendChild(mapLink);
                });
            } else {
                const row = recentFinishesTableBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 6;
                cell.textContent = "No recent finishes found.";
                cell.style.textAlign = 'center';
                cell.style.padding = '20px';
            }
            
            const favouriteTeammatesTableBody = document.getElementById('favouriteTeammatesTableBody');
            favouriteTeammatesTableBody.innerHTML = '';
            if (playerData.favourite_teammates && playerData.favourite_teammates.length > 0) {
                playerData.favourite_teammates.forEach(teammate => {
                    const row = favouriteTeammatesTableBody.insertRow();
                    row.insertCell().textContent = teammate.name || 'N/A';
                    row.insertCell().textContent = teammate.ranks_together || 0;
                });
            } else {
                const row = favouriteTeammatesTableBody.insertRow();
                const cell = row.insertCell();
                cell.colSpan = 2;
                cell.textContent = "No favourite teammates found.";
                cell.style.textAlign = 'center';
                cell.style.padding = '20px';
            }

            const playtimeCtx = document.getElementById('playtimeChart').getContext('2d');
            if (playtimeChartInstance) { // Destroy existing chart if it exists
                playtimeChartInstance.destroy();
            }
            if (playerData.playtime_per_month && playerData.playtime_per_month.length > 0) {
                const playtimeLabels = playerData.playtime_per_month.map(item => item.month);
                const playtimeData = playerData.playtime_per_month.map(item => Math.round(item.seconds_played / 3600));

                playtimeChartInstance = new Chart(playtimeCtx, {
                    type: 'line',
                    data: {
                        labels: playtimeLabels,
                        datasets: [{
                            label: 'Hours Played',
                            data: playtimeData,
                            borderColor: 'var(--primary-color)',
                            backgroundColor: 'rgba(85, 172, 238, 0.2)',
                            tension: 0.3,
                            fill: true,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Hours Played',
                                    color: 'white'
                                },
                                ticks: {
                                    color: 'white',
                                    callback: function(value) {
                                        return value + 'h';
                                    }
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.2)'
                                }
                            },
                            x: {
                                reverse: true,
                                title: {
                                    display: true,
                                    text: 'Month',
                                    color: 'white'
                                },
                                ticks: {
                                    color: 'white',
                                    autoSkip: true,
                                    maxTicksLimit: 20
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.2)'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: 'white'
                                }
                            },
                             tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y + 'h';
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            } else {
                playtimeCtx.clearRect(0, 0, playtimeCtx.canvas.width, playtimeCtx.canvas.height);
                playtimeCtx.font = "18px 'SF Pro Rounded'";
                playtimeCtx.fillStyle = 'white';
                playtimeCtx.textAlign = 'center';
                playtimeCtx.fillText('No playtime data available.', playtimeCtx.canvas.width / 2, playtimeCtx.canvas.height / 2);
            }

            const pointsCtx = document.getElementById('pointsChart').getContext('2d');
            if (pointsChartInstance) { // Destroy existing chart if it exists
                pointsChartInstance.destroy();
            }
            if (playerData.points_graph && playerData.points_graph.length > 0) {
                const filteredPointsGraph = [];
                if (playerData.points_graph.length > 0) {
                    filteredPointsGraph.push(playerData.points_graph[0]);
                    for (let i = 1; i < playerData.points_graph.length; i++) {
                        if (playerData.points_graph[i].points !== playerData.points_graph[i - 1].points) {
                            filteredPointsGraph.push(playerData.points_graph[i]);
                        }
                    }
                }

                const pointsLabels = filteredPointsGraph.map(item => item.date);
                const pointsData = filteredPointsGraph.map(item => item.points);

                pointsChartInstance = new Chart(pointsCtx, {
                    type: 'line',
                    data: {
                        labels: pointsLabels,
                        datasets: [{
                            label: 'Points',
                            data: pointsData,
                            borderColor: 'var(--primary-color)',
                            backgroundColor: 'rgba(235, 164, 52, 0.2)',
                            tension: 0.3,
                            fill: true,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Points',
                                    color: 'white'
                                },
                                ticks: {
                                    color: 'white'
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.2)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date',
                                    color: 'white'
                                },
                                ticks: {
                                    color: 'white',
                                    autoSkip: true,
                                    maxTicksLimit: 20
                                },
                                grid: {
                                    color: 'rgba(255, 255, 255, 0.2)'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: {
                                    color: 'white'
                                }
                            }
                        }
                    }
                });
            } else {
                pointsCtx.clearRect(0, 0, pointsCtx.canvas.width, pointsCtx.canvas.height);
                pointsCtx.font = "18px 'SF Pro Rounded'";
                pointsCtx.fillStyle = 'white';
                pointsCtx.textAlign = 'center';
                pointsCtx.fillText('No points data available.', pointsCtx.canvas.width / 2, pointsCtx.canvas.height / 2);
            }

            playerStatsContainer.style.display = 'block';
            document.getElementById('playerComparisonSection').style.display = 'block';
        }

        function displayError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
            playerStatsContainer.style.display = 'none';
            loadingIndicator.style.display = 'none';
            document.getElementById('playerComparisonSection').style.display = 'none';
        }

        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return 'N/A';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = seconds % 60;

            let parts = [];
            if (hours > 0) parts.push(`${hours}h`);
            if (minutes > 0) parts.push(`${minutes}m`);
            if (remainingSeconds > 0 || (hours === 0 && minutes === 0 && seconds === 0)) parts.push(`${remainingSeconds.toFixed(0)}s`);

            return parts.join(' ');
        }

        function sharePlayerProfile() {
            if (currentPlayerName) {
                const shareUrl = `${window.location.origin}${window.location.pathname}?player=${encodeURIComponent(currentPlayerName)}`;
                const tempInput = document.createElement('textarea');
                tempInput.value = shareUrl;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);

                const tooltip = document.createElement('div');
                tooltip.textContent = 'Link Copied!';
                tooltip.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: #28a745;
                    color: white;
                    padding: 8px 16px;
                    border-radius: 4px;
                    z-index: 10000;
                    font-weight: 600;
                `;
                document.body.appendChild(tooltip);
                setTimeout(() => tooltip.remove(), 1500);
            } else {
                showCustomModal('No player profile loaded to share.');
            }
        }

        function showCustomModal(message) {
            const modalId = 'customAlertModal';
            let modal = document.getElementById(modalId);
            if (!modal) {
                modal = document.createElement('div');
                modal.id = modalId;
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10001;
                    opacity: 0;
                    visibility: hidden;
                    transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
                `;
                modal.innerHTML = `
                    <div style="
                        background: var(--glass-bg);
                        backdrop-filter: blur(15px);
                        border: 1px solid var(--glass-border);
                        border-radius: 12px;
                        padding: 30px;
                        text-align: center;
                        color: var(--primary-color);
                        max-width: 400px;
                        width: 90%;
                        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
                        position: relative;
                    ">
                        <p style="margin-bottom: 20px; font-size: 1.1em;">${message}</p>
                        <button style="
                            background-color: var(--primary-color);
                            color: white;
                            border: none;
                            border-radius: 8px;
                            padding: 10px 20px;
                            font-size: 16px;
                            cursor: pointer;
                            transition: background-color 0.3s ease;
                        " onclick="document.getElementById('${modalId}').style.opacity = '0'; document.getElementById('${modalId}').style.visibility = 'hidden';">OK</button>
                    </div>
                `;
                document.body.appendChild(modal);
            } else {
                modal.querySelector('p').textContent = message;
            }
            modal.style.opacity = '1';
            modal.style.visibility = 'visible';
        }

        const player1SearchInput = document.getElementById('player1SearchInput');
        const player2SearchInput = document.getElementById('player2SearchInput');
        const comparePlayersButton = document.getElementById('comparePlayersButton');
        const comparisonResultsDiv = document.getElementById('comparisonResults');
        const comparisonErrorMessage = document.getElementById('comparisonErrorMessage');

        async function comparePlayers() {
            const player1Name = player1SearchInput.value.trim();
            const player2Name = player2SearchInput.value.trim();

            comparisonResultsDiv.innerHTML = '';
            comparisonErrorMessage.style.display = 'none';

            if (!player1Name || !player2Name) {
                comparisonErrorMessage.textContent = "Please enter names for both players to compare.";
                comparisonErrorMessage.style.display = 'block';
                return;
            }

            comparisonResultsDiv.innerHTML = '<div style="text-align:center; padding:20px;"><div class="loading-indicator" style="display:block;">Loading comparison data...</div></div>';


            try {
                const [response1, response2] = await Promise.all([
                    fetch(`https://ddstats.tw/player/json?player=${encodeURIComponent(player1Name)}`),
                    fetch(`https://ddstats.tw/player/json?player=${encodeURIComponent(player2Name)}`)
                ]);

                const playerData1 = await response1.json();
                const playerData2 = await response2.json();

                if (!response1.ok || !playerData1.profile) {
                    throw new Error(`Player '${player1Name}' not found or no detailed data available.`);
                }
                if (!response2.ok || !playerData2.profile) {
                    throw new Error(`Player '${player2Name}' not found or no detailed data available.`);
                }

                displayComparisonResults(playerData1, playerData2);

            } catch (error) {
                console.error("Error comparing players:", error);
                comparisonErrorMessage.textContent = error.message || "Failed to compare players. Please try again.";
                comparisonErrorMessage.style.display = 'block';
                comparisonResultsDiv.innerHTML = '';
            }
        }

        function displayComparisonResults(player1Data, player2Data) {
            comparisonResultsDiv.innerHTML = '';

            const player1Card = createComparisonCard(player1Data);
            const player2Card = createComparisonCard(player2Data);

            comparisonResultsDiv.appendChild(player1Card);
            comparisonResultsDiv.appendChild(player2Card);
        }

        function createComparisonCard(playerData) {
            const card = document.createElement('div');
            card.className = 'comparison-player-card';

            const profile = playerData;
            let totalSecondsPlayed = 0;
            if (playerData.finishes) {
                playerData.finishes.forEach(finish => {
                    totalSecondsPlayed += finish.seconds_played || 0;
                });
            }               
            const regionNames = new Intl.DisplayNames(

                ['en'], {type: 'region'}

            );

            const countryCode = profile.recent_player_info[0].country !== undefined && profile.recent_player_info[0].country !== null ? profile.recent_player_info[0].country.toString() : "-1";
            const countryNamey = COUNTRY_CODES[countryCode] || "Unknown";

            const countryName = countryNamey === "default" ? "Default" : regionNames.of(countryNamey);

            card.innerHTML = `
                <h3>${profile.profile.name || 'N/A'}</h3>
                <p>Points: <span>${profile.profile.points || 0}</span></p>
                <p>Clan: <span>${profile.recent_player_info[0].clan || 'N/A'}</span></p>
                <p class="country-display">Country: <span>${countryName}</span></p>
                <p>Total Finishes: <span>${playerData.finishes ? playerData.finishes.length : 0}</span></p>
                <p>Total Time Played: <span>${formatTime(playerData.general_activity.total_seconds_played)}</span></p>
                <p>Is Mapper: <span>${playerData.is_mapper ? 'Yes' : 'No'}</span></p>
            `;
            return card;
        }

        searchPlayerButton.addEventListener('click', searchPlayer);
        playerSearchInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                searchPlayer();
            }
        });
        document.addEventListener('DOMContentLoaded', () => {
        const teeAssemblerContainer = document.querySelector('.teeassembler-tee');
        if (teeAssemblerContainer) {
            teeAssemblerContainer.addEventListener('click', () => {
                if (currentTeeAssemblerString) {
                    const tempInput = document.createElement('textarea');
                    tempInput.value = currentTeeAssemblerString;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    document.execCommand('copy');
                    document.body.removeChild(tempInput);
                    showCustomModal('Copied to clipboard: ' + currentTeeAssemblerString);
                } else {
                    showCustomModal('No player skin data to copy.');
                }
            });
        }
    });

        comparePlayersButton.addEventListener('click', comparePlayers);
        player1SearchInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                comparePlayers();
            }
        });
        player2SearchInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                comparePlayers();
            }
        });

        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const playerNameFromUrl = urlParams.get('player');
            if (playerNameFromUrl) {
                playerSearchInput.value = playerNameFromUrl;
                searchPlayer();
            } else {
                playerSearchInput.value = '';
                searchPlayer(); 
            }
        });
    </script>
    <script type="module">

    </script>
</body>
</html>
